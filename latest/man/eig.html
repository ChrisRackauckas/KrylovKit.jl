<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Finding eigenvalues and eigenvectors · KrylovKit.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>KrylovKit.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="intro.html">Introduction</a></li><li><a class="toctext" href="linear.html">Solving linear systems</a></li><li class="current"><a class="toctext" href="eig.html">Finding eigenvalues and eigenvectors</a><ul class="internal"></ul></li><li><a class="toctext" href="svd.html">Finding singular values and singular vectors</a></li><li><a class="toctext" href="matfun.html">Functions of matrices and linear maps</a></li><li><a class="toctext" href="algorithms.html">Available algorithms</a></li><li><a class="toctext" href="implementation.html">Details of the implementation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="eig.html">Finding eigenvalues and eigenvectors</a></li></ul><a class="edit-page" href="https://github.com/Jutho/KrylovKit.jl/blob/master/docs/src/man/eig.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Finding eigenvalues and eigenvectors</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Finding-eigenvalues-and-eigenvectors-1" href="#Finding-eigenvalues-and-eigenvectors-1">Finding eigenvalues and eigenvectors</a></h1><p>Finding a selection of eigenvalues and corresponding (right) eigenvectors of a linear map can be accomplished with the <code>eigsolve</code> routine:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.eigsolve" href="#KrylovKit.eigsolve"><code>KrylovKit.eigsolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">eigsolve(A::AbstractMatrix, [howmany = 1, which = :LM, T = eltype(A)]; kwargs...)
eigsolve(f, n::Int, [howmany = 1, which = :LM, T = Float64]; kwargs...)
eigsolve(f, x₀, [howmany = 1, which = :LM]; kwargs...)
eigsolve(f, x₀, howmany, which, algorithm)</code></pre><p>Compute <code>howmany</code> eigenvalues from the linear map encoded in the matrix <code>A</code> or by the function <code>f</code>. Return eigenvalues, eigenvectors and a <code>ConvergenceInfo</code> structure.</p><p><strong>Arguments:</strong></p><p>The linear map can be an <code>AbstractMatrix</code> (dense or sparse) or a general function or callable object. If an <code>AbstractMatrix</code> is used, a starting vector <code>x₀</code> does not need to be provided, it is then chosen as <code>rand(T, size(A,1))</code>. If the linear map is encoded more generally as a a callable function or method, the best approach is to provide an explicit starting guess <code>x₀</code>. Note that <code>x₀</code> does not need to be of type <code>AbstractVector</code>, any type that behaves as a vector and supports the required methods (see KrylovKit docs) is accepted. If instead of <code>x₀</code> an integer <code>n</code> is specified, it is assumed that <code>x₀</code> is a regular vector and it is initialized to <code>rand(T,n)</code>, where the default value of <code>T</code> is <code>Float64</code>, unless specified differently.</p><p>The next arguments are optional, but should typically be specified. <code>howmany</code> specifies how many eigenvalues should be computed; <code>which</code> specifies which eigenvalues should be targetted. Valid specifications of <code>which</code> are given by</p><ul><li><code>LM</code>: eigenvalues of largest magnitude</li><li><code>LR</code>: eigenvalues with largest (most positive) real part</li><li><code>SR</code>: eigenvalues with smallest (most negative) real part</li><li><code>LI</code>: eigenvalues with largest (most positive) imaginary part, only if <code>T &lt;: Complex</code></li><li><code>SI</code>: eigenvalues with smallest (most negative) imaginary part, only if <code>T &lt;: Complex</code></li><li><a href="man/@ref"><code>ClosestTo(λ)</code></a>: eigenvalues closest to some number <code>λ</code></li></ul><div class="admonition note"><div class="admonition-title">Note about selecting `which` eigenvalues</div><div class="admonition-text"><p>Krylov methods work well for extremal eigenvalues, i.e. eigenvalues on the periphery of the spectrum of the linear map. Even with <code>ClosestTo</code>, no shift and invert is performed. This is useful if, e.g., you know the spectrum to be within the unit circle in the complex plane, and want to target the eigenvalues closest to the value <code>λ = 1</code>.</p></div></div><p>The argument <code>T</code> acts as a hint in which <code>Number</code> type the computation should be performed, but is not restrictive. If the linear map automatically produces complex values, complex arithmetic will be used even though <code>T&lt;:Real</code> was specified.</p><p><strong>Return values:</strong></p><p>The return value is always of the form <code>vals, vecs, info = eigsolve(...)</code> with</p><ul><li><code>vals</code>: a <code>Vector</code> containing the eigenvalues, of length at least <code>howmany</code>, but could be   longer if more eigenvalues were converged at the same cost. Eigenvalues will be real if   <a href="algorithms.html#KrylovKit.Lanczos"><code>Lanczos</code></a> was used and complex if <a href="algorithms.html#KrylovKit.Arnoldi"><code>Arnoldi</code></a> was used (see below).</li><li><code>vecs</code>: a <code>Vector</code> of corresponding eigenvectors, of the same length as <code>vals</code>. Note that   eigenvectors are not returned as a matrix, as the linear map could act on any custom Julia   type with vector like behavior, i.e. the elements of the list <code>vecs</code> are objects that are   typically similar to the starting guess <code>x₀</code>, up to a possibly different <code>eltype</code>. In particular,   for a general matrix (i.e. with <code>Arnoldi</code>) the eigenvectors are generally complex and are   therefore always returned in a complex number format.   When the linear map is a simple <code>AbstractMatrix</code>, <code>vecs</code> will be <code>Vector{Vector{&lt;:Number}}</code>.</li><li><code>info</code>: an object of type [<code>ConvergenceInfo</code>], which has the following fields<ul><li><code>info.converged::Int</code>: indicates how many eigenvalues and eigenvectors were actually   converged to the specified tolerance <code>tol</code> (see below under keyword arguments)</li><li><code>info.residual::Vector</code>: a list of the same length as <code>vals</code> containing the residuals   <code>info.residual[i] = f(vecs[i]) - vals[i] * vecs[i]</code></li><li><code>info.normres::Vector{&lt;:Real}</code>: list of the same length as <code>vals</code> containing the norm   of the residual <code>info.normres[i] = norm(info.residual[i])</code></li><li><code>info.numops::Int</code>: number of times the linear map was applied, i.e. number of times   <code>f</code> was called, or a vector was multiplied with <code>A</code></li><li><code>info.numiter::Int</code>: number of times the Krylov subspace was restarted (see below)</li></ul></li></ul><div class="admonition warning"><div class="admonition-title">Check for convergence</div><div class="admonition-text"><p>No warning is printed if not all requested eigenvalues were converged, so always check if <code>info.converged &gt;= howmany</code>.</p></div></div><p><strong>Keyword arguments:</strong></p><p>Keyword arguments and their default values are given by:</p><ul><li><code>krylovdim = 30</code>: the maximum dimension of the Krylov subspace that will be constructed.   Note that the dimension of the vector space is not known or checked, e.g. <code>x₀</code> should not   necessarily support the <code>Base.length</code> function. If you know the actual problem dimension   is smaller than the default value, it is useful to reduce the value of <code>krylovdim</code>, though   in principle this should be detected.</li><li><code>tol = 1e-12</code>: the requested accuracy (corresponding to the 2-norm of the residual for   Schur vectors, not the eigenvectors). If you work in e.g. single precision (<code>Float32</code>),   you should definitely change the default value.</li><li><code>maxiter = 100</code>: the number of times the Krylov subspace can be rebuilt; see below for   further details on the algorithms.</li><li><code>issymmetric</code>: if the linear map is symmetric, only meaningful if <code>T&lt;:Real</code></li><li><code>ishermitian</code>: if the linear map is hermitian</li></ul><p>The default value for the last two depends on the method. If an <code>AbstractMatrix</code> is used, <code>issymmetric</code> and <code>ishermitian</code> are checked for that matrix, ortherwise the default values are <code>issymmetric = false</code> and <code>ishermitian = T &lt;: Real &amp;&amp; issymmetric</code>.</p><p><strong>Algorithm</strong></p><p>The last method, without default values and keyword arguments, is the one that is finally called, and can also be used directly. Here, one specifies the algorithm explicitly as either <a href="algorithms.html#KrylovKit.Lanczos"><code>Lanczos</code></a>, for real symmetric or complex hermitian problems, or <a href="algorithms.html#KrylovKit.Arnoldi"><code>Arnoldi</code></a>, for general problems. Note that these names refer to the process for building the Krylov subspace, but the actual algorithm is an implementation of the Krylov-Schur algorithm, which can dynamically shrink and grow the Krylov subspace, i.e. the restarts are so-called thick restarts where a part of the current Krylov subspace is kept.</p><div class="admonition note"><div class="admonition-title">Note about convergence</div><div class="admonition-text"><p>In case of a general problem, where the <code>Arnoldi</code> method is used, convergence of an eigenvalue is not based on the norm of the residual <code>norm(f(vecs[i]) - vals[i]*vecs[i])</code> for the eigenvectors but rather on the norm of the residual for the corresponding Schur vectors.</p><p>See also <a href="eig.html#KrylovKit.schursolve"><code>schursolve</code></a> if you want to use the partial Schur decomposition directly, or if you are not interested in computing the eigenvectors, and want to work in real arithmetic all the way true (if the linear map and starting guess are real).</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/689cf329964ddcfff76bbce54d757fdcb208dda4/src/eigsolve/eigsolve.jl#L1-L100">source</a></section><p>For a general matrix, eigenvalues and eigenvectors will always be returned with complex values for reasons of type stability. However, if the linear map and initial guess are real, most of the computation is actually performed using real arithmetic, as in fact the first step is to compute an approximate partial Schur factorization. If one is not interested in the eigenvectors, one can also just compute this partial Schur factorization using <code>schursolve</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="KrylovKit.schursolve" href="#KrylovKit.schursolve"><code>KrylovKit.schursolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">schursolve(A, x₀, howmany, which, algorithm)</code></pre><p>Compute a partial Schur decomposition containing <code>howmany</code> eigenvalues from the linear map encoded in the matrix or function <code>A</code>. Return the reduced Schur matrix, the basis of Schur vectors, the extracted eigenvalues and a <code>ConvergenceInfo</code> structure.</p><p>See also <a href="man/@eigsolve"><code>eigsolve</code></a> to obtain the eigenvectors instead. For real symmetric or complex hermitian problems, the (partial) Schur decomposition is identical to the (partial) eigenvalue decomposition, and <code>eigsolve</code> should always be used.</p><p><strong>Arguments:</strong></p><p>The linear map can be an <code>AbstractMatrix</code> (dense or sparse) or a general function or callable object, that acts on vector like objects similar to <code>x₀</code>, which is the starting guess from which a Krylov subspace will be built. <code>howmany</code> specifies how many Schur vectors should be converged before the algorithm terminates; <code>which</code> specifies which eigenvalues should be targetted. Valid specifications of <code>which</code> are</p><ul><li><code>LM</code>: eigenvalues of largest magnitude</li><li><code>LR</code>: eigenvalues with largest (most positive) real part</li><li><code>SR</code>: eigenvalues with smallest (most negative) real part</li><li><code>LI</code>: eigenvalues with largest (most positive) imaginary part, only if <code>T &lt;: Complex</code></li><li><code>SI</code>: eigenvalues with smallest (most negative) imaginary part, only if <code>T &lt;: Complex</code></li><li><a href="man/@ref"><code>ClosestTo(λ)</code></a>: eigenvalues closest to some number <code>λ</code></li></ul><div class="admonition note"><div class="admonition-title">Note about selecting `which` eigenvalues</div><div class="admonition-text"><p>Krylov methods work well for extremal eigenvalues, i.e. eigenvalues on the periphery of the spectrum of the linear map. Even with <code>ClosestTo</code>, no shift and invert is performed. This is useful if, e.g., you know the spectrum to be within the unit circle in the complex plane, and want to target the eigenvalues closest to the value <code>λ = 1</code>.</p></div></div><p>The final argument <code>algorithm</code> can currently only be an instance of <a href="algorithms.html#KrylovKit.Arnoldi"><code>Arnoldi</code></a>, but should nevertheless be specified. Since <code>schursolve</code> is less commonly used as <code>eigsolve</code>, no convenient keyword syntax is currently available.</p><p><strong>Return values:</strong></p><p>The return value is always of the form <code>T, vecs, vals, info = eigsolve(...)</code> with</p><ul><li><code>T</code>: a <code>Matrix</code> containing the partial Schur decomposition of the linear map, i.e. it&#39;s   elements are given by <code>T[i,j] = dot(vecs[i], f(vecs[j]))</code>. It is of Schur form, i.e. upper   triangular in case of complex arithmetic, and block upper triangular (with at most 2x2 blocks)   in case of real arithmetic.</li><li><code>vecs</code>: a <code>Vector</code> of corresponding Schur vectors, of the same length as <code>vals</code>. Note that   Schur vectors are not returned as a matrix, as the linear map could act on any custom Julia   type with vector like behavior, i.e. the elements of the list <code>vecs</code> are objects that are   typically similar to the starting guess <code>x₀</code>, up to a possibly different <code>eltype</code>. When   the linear map is a simple <code>AbstractMatrix</code>, <code>vecs</code> will be <code>Vector{Vector{&lt;:Number}}</code>.   Schur vectors are by definition orthogonal, i.e. <code>dot(vecs[i],vecs[j]) = I[i,j]</code>. Note that   Schur vectors are real if the problem (i.e. the linear map and the initial guess) are real.</li><li><code>vals</code>: a <code>Vector</code> of eigenvalues, i.e. the diagonal elements of <code>T</code> in case of complex   arithmetic, or extracted from the diagonal blocks in case of real arithmetic. Note that   <code>vals</code> will always be complex, independent of the underlying arithmetic.</li><li><code>info</code>: an object of type [<code>ConvergenceInfo</code>], which has the following fields<ul><li><code>info.converged::Int</code>: indicates how many eigenvalues and Schur vectors were actually   converged to the specified tolerance (see below under keyword arguments)</li><li><code>info.residuals::Vector</code>: a list of the same length as <code>vals</code> containing the actual   residuals   <code>julia     info.residuals[i] = f(vecs[i]) - sum(vecs[j]*T[j,i] for j = 1:i+1)</code>   where <code>T[i+1,i]</code> is definitely zero in case of complex arithmetic and possibly zero   in case of real arithmetic</li><li><code>info.normres::Vector{&lt;:Real}</code>: list of the same length as <code>vals</code> containing the norm   of the residual for every Schur vector, i.e. <code>info.normes[i] = norm(info.residual[i])</code></li><li><code>info.numops::Int</code>: number of times the linear map was applied, i.e. number of times   <code>f</code> was called, or a vector was multiplied with <code>A</code></li><li><code>info.numiter::Int</code>: number of times the Krylov subspace was restarted (see below)</li></ul></li></ul><div class="admonition warning"><div class="admonition-title">Check for convergence</div><div class="admonition-text"><p>No warning is printed if not all requested eigenvalues were converged, so always check if <code>info.converged &gt;= howmany</code>.</p></div></div><p><strong>Algorithm</strong></p><p>The actual algorithm is an implementation of the Krylov-Schur algorithm, where the <a href="algorithms.html#KrylovKit.Arnoldi"><code>Arnoldi</code></a> algorithm is used to generate the Krylov subspace. During the algorith, the Krylov subspace is dynamically grown and shrunk, i.e. the restarts are so-called thick restarts where a part of the current Krylov subspace is kept.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Jutho/KrylovKit.jl/blob/689cf329964ddcfff76bbce54d757fdcb208dda4/src/eigsolve/arnoldi.jl#L1-L74">source</a></section><p>Note that, for symmetric or hermitian linear maps, the eigenvalue and Schur factorizaion are equivalent, and one can only use <code>eigsolve</code>.</p><p>Another example of a possible use case of <code>schursolve</code> is if the linear map is known to have a unique eigenvalue of, e.g. largest magnitude. Then, if the linear map is real valued, that largest magnitude eigenvalue and its corresponding eigenvector are also real valued. <code>eigsolve</code> will automatically return complex valued eigenvectors for reasons of type stability. However, as the first Schur vector will coincide with the first eigenvector, one can instead use</p><pre><code class="language-julia">T, vecs, vals, info = schursolve(A, x⁠₀, 1, :LM, Arnoldi(...))</code></pre><p>and use <code>vecs[1]</code> as the real valued eigenvector (after checking <code>info.converged</code>) corresponding to the largest magnitude eigenvalue of <code>A</code>.</p><footer><hr/><a class="previous" href="linear.html"><span class="direction">Previous</span><span class="title">Solving linear systems</span></a><a class="next" href="svd.html"><span class="direction">Next</span><span class="title">Finding singular values and singular vectors</span></a></footer></article></body></html>
